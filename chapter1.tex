%----------------------------------------------------------------------------
\chapter{Korábbi munkám áttekintése}
%----------------------------------------------------------------------------
%----------------------------------------------------------------------------
\section{Rövid ismertetõ}
%----------------------------------------------------------------------------
BSc-s szakdolgozatom keretében egy komponens alapú játékmotort készítettem, melyet meglevõ
megjelenítési és fizikai alrendszereket felhasználva készítettem el. A felhasznált technológiákról
részletesebben az \autoref{subsec:3rdparty} -ben térek ki.

az engine-t dll-be fordítottam, ezt használta a példa alkalmazás
%----------------------------------------------------------------------------
\section{A komponens alapú megközelítés}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Öröklés esetén felmerülõ problémák}
%----------------------------------------------------------------------------
Képzeljük el a következõt: öröklésen alapú rendszert akarunk létrehozni, melynek alapja egy absztrakt
õsosztály, \textit{GameObject} néven. Ebbõl az õsosztályból örököltetünk egy \textit{Dynamic} és egy
\textit{Static} osztályt, melyek a mozgó és nem mozgó játékobjektumokat reprezentálják.
De ezek még mindig absztrakt osztályok, vagyis nem lehet õket példányosítani.
Ahhoz, hogy objektumokat kapjunk, további leszármazásokat kell tennünk. Legyen egy \textit{Dynamic}
leszármazott \textit{Car} néven, illetve egy \textit{Static} leszármazott \textit{House} néven.
Ezeken felül ha létrehozunk egy \textit{Caravan} osztályt, mely származik a \textit{Car} és a
\textit{House} osztályból is, akkor máris fatális logikai hibába ütköztünk, hiszen a \textit{Caravan}
az egyszerre \textit{Dynamic} és \textit{Static} is, ami természetesen ellentmondáshoz vezet (\figref{BadInheritance} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=40mm, keepaspectratio]{figures/bad_inheritance.png}
\caption{Ellentmondás: a Caravan egyszerre Dynamic és Static is} 
\label{fig:BadInheritance}
\end{figure}

Az olvasó gondolataiban persze jogosan megfogalmazódhat, hogy ezt az egyszerû rendszert
le lehetne cserélni egy olyanra, ahol problémamentesen megférne egymás mellet az autó, a ház illetve
a lakókocsi osztály is. Ez így is van, de a gyakorlatban nem három, hanem sokkal több játékobjektummal
kell dolgozniuk a programozóknak, s egy hatalmas öröklési rendszerbe beszúrni egy újabb típusú
játékobjektumot sokszor vezethet hasonló anomáliákhoz, mint amilyet az elõbbiekben ismertettem.

Ezek után már talán nem is olyan meglepõ, hogy az iparban manapság nem az öröklésen alapuló rendszereket
részesítik elõnyben. A továbbiakban egy alternatív megközelítést ismertetek.

%----------------------------------------------------------------------------
\subsection{Leszármazás helyett tartalmazás}
%----------------------------------------------------------------------------
Ebben a rendszerben kizárólag egyetlen játékobjektum osztály van, illetve ezen kívül vannak komponensek
is. Minden komponens egyetlen jól meghatározott funkcionalitásért felel, például a kirajzolásért, a
fizikáért, stb. Általában ilyen rendszerek esetén a felhasználónak is lehetõsége van új komponensek
létrehozására.

A módszer lényege, hogy a játékobjektum tulajdonságait kizárólag az határozza meg, hogy milyen típusú
komponensek vannak hozzárendelve, vagyis a játékobjektumtól elcsatoljuk annak tulajdonságait (\figref{ComponentBased} ábra).
Ez egyszerre lehet áldás és átok is. Áldás, hiszen egy ilyen rendszer sokkal rugalmasabb és karbantarthatóbb lehet,
mint az öröklésen alapuló megoldás (gondoljunk csak arra, hogy az objektumok tulajdonságait dinamikusan,
futás közben is nagyon egyszerûen módosíthatjuk), emellett viszont átok is egyben, hiszen egy ilyen rendszer
megvalósításához el kell vonatkoztatnunk attól az objektumorientált szemléletmódtól, amiben
egyébként a programozók jelentõs hányada képes gondolkodni.

\begin{figure}[!ht]
\centering
\includegraphics[width=70mm, keepaspectratio]{figures/component_based.png}
\caption{Funkcionalitás elcsatolása az objektumtól}
\label{fig:ComponentBased}
\end{figure}

Ennek a módszernek a segítségével az elõzõ szakaszban felvetett problémát egyszerûen meg lehet oldani.
Ehhez létre kell hozni három \textit{GameObject} példányt a megfelelõ komponensekkel. A \textit{Car}
objektumhoz a \textit{WheelComponent} komponenst, a \textit{House} objektumhoz a \textit{KitchenComponent}
komponenst illetve a \textit{Caravan} objektumhoz mindkét elõbb említett komponenst
hozzárendeljük (\figref{SolutionWithComponents} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=60mm, keepaspectratio]{figures/all_compbased.png}
\caption{A feladat megoldása komponensekkel}
\label{fig:SolutionWithComponents}
\end{figure}

%----------------------------------------------------------------------------
\section{Felhasznált technológiák}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Programozási nyelv és fejlesztõkörnyezet}
%----------------------------------------------------------------------------
Visual Studio 2010
%----------------------------------------------------------------------------
\subsection{3rdparty alrendszerek}
\label{subsec:3rdparty}
%----------------------------------------------------------------------------
Természetesen nem volt - és nem is lehetett - célja a szakdolgozatomnak, hogy minden egyes
funkcionalitást saját magam implementáljak, hiszen ennek a véghez vitele túlmutatott volna a tantárgy terjedelmi és idõkorlátain. Ennek megfelelõen a fontosabb részfeladatokhoz már meglevõ, ingyenes és
platform-független eszközöket használtam fel, melyeket a továbbiakban ismertetek.
%----------------------------------------------------------------------------
\subsubsection{OGRE 3D}
%----------------------------------------------------------------------------
A játékmotorok egyik legalapvetõbb funkcionalitása a virtuális világ megjelenítésének képessége.
Ennek megvalósításához különféle grafikai alrendszereket használnak fel, melyek lehetnek a motortól teljesen külön váló külsõ könyvtárak, vagy éppen a motorhoz fejlesztett belsõ eszközök is. Az én megvalósításomban nem volt cél egy ilyen belsõ eszköz megvalósítása, így egy erre a célra alkalmas külsõ könyvtárat, az OGRE-t használtam fel, melyet az alábbiakban ismertetek.

Az OGRE (\textbf{O}bject-Oriented \textbf{G}raphics \textbf{R}endering \textbf{E}ngine), vagyis
az objektumorientált grafikai megjelenítõ motor egy színtér alapú, rugalmas 3D grafikai motor,
melyet C++ nyelven készítettek\cite{OGRE}. Célja, hogy könnyebbé tegye a fejlesztõk számára olyan alkalmazások készítését, melyek hardveresen gyorsított grafikai megjelenítéseket is igénybe vehetnek. Ez a könyvtár elvonatkoztat az alatta levõ grafikai könyvtáraktól (mint például DirectX, OpenGL), s ezek használatához biztosít egy egységes interfészt a szoftverrendszer többi szereplõje számára.

Jónéhány grafikai motorral ellentétben tervezés-orientált, s nem funkció-orientált módon készült, vagyis a fejlesztés során a letisztult szoftver-struktúra legalább olyan fontos volt, mint a megvalósított funkciók mennyisége. Ennek köszönhetõen kellõen általános lett ahhoz, hogy bármilyen típusú játék elkészítéséhez megfelelõen alkalmazható legyen. Ezek mellett a meglehetõsen gazdag dokumentációja is hozzájárult ahhoz, hogy ilyen mértékben elterjedjen a játékfejlesztõk körében.

Elterjedtségének ellenére azonban az OGRE népszerûsége folyamatosan csökken. Ez többek között
betudható annak, hogy a fejlesztõi közösség az utóbbi idõben nem mutatott megfelelõ aktivitást
(a Visual Studio 2015-höz fordított 1.9-es SDK 2016 decemberében jelent meg, s azt is csak egy fórumozó kommentjében lehetett megtalálni), illetve magyarázható azzal a tendenciával is, hogy manapság a játékfejlesztõk elõnyben részesítik azokat a szoftver-rendszereket, melyek nem csak a megjelenítésért, hanem más funkcionalitások elvégzéséért is felelõsek. Ez azonban nem kizárólag az OGRE problémája, hiszen általánosságban elmondható, hogy az általános célú játékmotorok kezdik kiszorítnani a piacról a funkció-specifikus motorokat.
%----------------------------------------------------------------------------
\subsubsection{OIS}
%----------------------------------------------------------------------------
Object Oriented Input System

OGRE-tol fuggetlen???

%----------------------------------------------------------------------------
\subsubsection{Boost}
%----------------------------------------------------------------------------
C++ konyvtarcsomag, wikipedia es google segit

en explcite nem hasznalom, az OGRE-nek kell

%----------------------------------------------------------------------------
\subsubsection{Bullet}
%----------------------------------------------------------------------------
A virtuális világ megjelenítése csak a legritkább esetben elegendõ egy grafikus alkalmazás - 
például egy számítógépes játék - elkészítéséhez. Manapság szinte kötelezõ eleme a játékmotoroknak
valamilyen fizikai motor, mely a programozók által felparaméterezett fizikai világ viselkedését képes
szimulálni - bizonyos keretek között - valós idõben.

Az ilyen alrendszerek elkészítése közel sem triviális feladat, így levéve ezt a terhet a
játéklogika-programozók válláról az én motorom is tartalmaz fizikai alrendszert, melynek megvalósításához
a Bullet nevû fizikai motort használtam fel\cite{Bullet}.

A Bullet ingyenes, platform független, nyílt forráskódú fizikai motor. Fõbb funkciói között megemlítendõ
a merev- és puhatest szimuláció illetve a diszkrét és folytonos ütközés-detektálás. Jelenlegi legfrissebb
stabil verziója a 2.87-es.

Ami a piaci alkalmazását illeti, a számítógépes játékok területén ezt a szoftvert használták fizikai szimulációkhoz a Rockstar Games számos alkotásánál (GTA IV, GTA V, Red Dead Redemption), az Activision cég Blood Drive nevezetû játékánál, vagy éppen a DIRT sorozat összes részénél. Számos hollywood-i alkotás is
alkalmazta már a Bullet-et merev testek fizikai szimulációinál a speciális effektek megalkotásához. Példaként megemlíthetõ a Shrek 4 a PDI/Dreamworks-tõl, vagy a Framestore 2009-es közremûködésével létrejött Sherlock Holmes film.
%----------------------------------------------------------------------------
\subsubsection{TinyXML}
%----------------------------------------------------------------------------
C++-ban írt, platformfüggetlen, nyílt forráskódú, ingyenes XML feldolgozó.

%----------------------------------------------------------------------------
\subsection{Verziókezelõ rendszer}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsubsection{Verziókezelõ rendszerekrõl általában}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsubsection{A Git verziókezelõ rendszer ismertetése}
%----------------------------------------------------------------------------