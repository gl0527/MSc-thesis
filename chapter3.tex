%----------------------------------------------------------------------------
\chapter{A játékmotor bõvítése}
%----------------------------------------------------------------------------
Ez a fejezet tartalmazza a Bevezetõ fejezetben ismertetett feladataimnak a megoldásait.

Elsõként bemutatja a játékobjektumok késleltetett létrehozásának megvalósítását, aztán az
állapotgép alapú rendszerek taglalását követõen az animációs alrendszer és a mesterséges intelligencia
alrendszer implementálását ismerteti. Ezt követõen részletezi a felhasználói felület létrehozásának módját.
Végezetül a fejezet a -- már alapjaiben eddig is meglevõ -- hangrendszer illetve részecskerendszer
továbbfejlesztésével illetve az elkészült rendszer áttekintésével zárul.

%----------------------------------------------------------------------------
\section{Játékobjektumok késleltetett létrehozása}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Motiváció}
%----------------------------------------------------------------------------
Korábban az XML parszolás azt határozta meg, hogy milyen legyen a betöltött virtuális világ a
kezdeti idõpontjában. Nem volt lehetõség olyan objektumok definiálására, melyek példányosítását
csak a virtuális világ egy késõbbi szakaszában lehetett volna véghez vinni.

Igény viszont lett volna erre a funkcionalitásra, gondoljunk csak egy lõfegyverre, mely valamilyen
lövedéket képes magából kibocsátani egy adott esemény -- például bal egérgomb lenyomása -- hatására.
A lövedék leírásának természetesen helye van az XML leíró fájlban, mégsem szeretnénk, ha az azonnal
betöltõdne. Persze azt sem tudhatjuk, hogy hány példányt definiáljunk a leíró fájlban, mert ez
kizárólag a felhasználótól függ. Viszont azt sem szeretnénk, ha minden lövedék-betöltés elõtt az XML
fájlhoz kellene fordulni, mert az nagyon lelassítaná a program futását (a háttértár elérési ideje
nagyságrendekkel nagyobb a memória elérési idejénél).

Másfelõl annak is van értelme, ha több féle lövedék típus létezik egy játékban, s ezeknek vannak közös
tulajdonságaik. Ebben az esetben is hasznos lenne egy olyan absztrakt játékobjektum definíció
az XML leírásban, melyet közvetlenül nem példányosítunk, viszont a tartalmát felhasználva
-- esetleg azt módosítva -- konkrét játékobjektumokat lehet létrehozni.

Ezen igények kielégítésére találták ki a prefab-okat, melyek implementálását a saját rendszeremben
az alábbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{Megvalósítás}
%----------------------------------------------------------------------------
Mindezen funkcionalitások megvalósítására lehetõvé tettem a motorom számára a játékobjektumok
késleltetett létrehozását. A megvalósításnak a lényege, hogy minden komponenshez definiálok egy-egy
leíró struktúrát, mely tartalmazza az összes olyan paramétert, mely átadható a hozzá tartozó
komponensnek. A leíró struktúrák mellett létrehoztam egy \textit{GenericPrefab} nevû generikus osztályt,
melynek feladata adott típusú létrehozó struktúra feltöltése és alkalmazása adott típusú komponensre.
A \textit{GenericPrefab} osztály a nem generikus \textit{IPrefab} interfészbõl származik le, melynek
a legfõbb létjogosultsága, hogy segítségével a különbözõ \textit{GenericPrefab} példányok
eltárolhatók heterogén kollekcióban. Az összetartozó \textit{GenericPrefab} példányokat
\textit{GameObjectCreator} példányban tárolom, melybõl szükség szerint lehet \textit{GameObject}
példányokat gyártani. A \textit{GameObjectCreator} objektumok az \textit{ObjectManager}-ben
foglalnak helyet.

A C++ oldal mellett a jelenet XML leírása is módosult természetesen. Az eddigi funkcionalitások mellett
a fejlesztõnek lehetõsége van prefab-ok megadására is. Egy ilyen objektum definiálása gyakorlatilag
megegyezik egy játékobjektum definiálásával, mindössze az XML tag-ek nevében van különbség (gameobject
helyett prefab). Mindemellett a felhasználó megadhatja azt is, hogy egy játékobjektum mely prefabból
példányosodik.

Ezen módosítások miatt módosítanom kellett a komponensek XML-bõl történõ beolvasásáért felelõs
osztályokat is. A korábbiakkal ellentétben ugyanis ezek az objektumok már nem konkrét komponens
leszármazottakat, hanem \textit{GenericPrefab}-okat hoznak létre. Szükség esetén természetesen
a \textit{GenericPrefab} példányból azonnal lehet komponens leszármazottat is készíteni, tehát a régi
funkcionalitás nem vész el. Viszont bõvül azzal, hogy a \textit{GenericPrefab} példányt elrakhatom egy
\textit{GameObjectCreator}-ba egy -- vagy több -- késõbbi használat reményében.


<DIAGRAM(OK)>

%----------------------------------------------------------------------------
\section{Állapotgép alapú rendszerek}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Az állapotgépekrõl általánosságban}
%----------------------------------------------------------------------------
Az állapotgépek - vagy ahogy a diszkrét matematika nevezi: véges automaták - véges állapothalmazzal
rendelkezõ absztrakt gépek. Definiálásához meg kell adni az állapotok halmazát, a kezdõ állapotot,
az ``elfogadó'' állapotok halmazát (ami a teljes állapothalmaz részhalmaza), az automata ábécéjét
(vagyis azt a halmazt, ami fölött értelmezve vannak az automata lehetséges bemenetei), illetve az
állapotátmeneti függvényeket, amik egy állapot-bemenet pároshoz egy állapotot rendelnek (vagyis ezek
a függvények megmondják, hogy ha egy adott állapotban egy adott input érkezik, akkor mely állapotba
kell átmennie az automatának).

Egy ilyen gép mûködése a következõ: adott egy véges hosszú input szalag illetve egy olvasófej,
mely kezdetben a szalag bal szélén helyezkedik el, s csak jobbra tud lépni. Az automata az aktuálisan
olvasott input és az állapotátmeneti függvények ismeretében minden lépésben meghatározza a saját következõ
állapotát. Ha az olvasófej az input végére ért, akkor két eset lehetséges: ha akkor elfogadó állapotba
ment át az automata, akkor az automata elfogadja a bemenetét, különben nem fogadja el.
%----------------------------------------------------------------------------
\subsection{A State tervezési minta}
%----------------------------------------------------------------------------
A tervezési minták gyakran elõforduló szoftverfejlesztési problémákra adnak
egy -- az ipar által elfogadott -- megoldást. Ez elsõre különösen hangozhat, hiszen egy
probléma megoldásának számos módja lehet egy adott programozási nyelven, miért van szükség
egyetlen megoldás kiemelésére? Természetesen ezek a megoldások csak ajánlások, használatukra nyílván
nem is lehetne kötelezni a programozókat, ráadásul ezek az ajánlott megoldások esetenként nem is
jelentik a ``legjobb'' megoldást a felmerülõ problémáinkra, ennek ellenére ezeknek a mintáknak
a használata -- az ismertségük miatt -- mindenképpen ajánlott. A használatot ebben az esetben nem úgy
kell érteni, hogy teljes mértékben azt valósítjuk meg, amit a minta állít, hanem hogy a minta által
sugallt megoldási ötletet felhasználva készítjük el az implementációt. Ha így járunk el, akkor a
tervezési mintákat ismerõ fejlesztõk könnyebben és így gyorsabban tudják értelmezni a kódjainkat.
Ehhez kapcsolódóan megjegyzendõ, hogy  -- fõleg tapasztalatlan fejlesztõk körében -- nem a minták
ignorálása, hanem épp ellenkezõleg, a minták túlhasználása szokta a gondot jelenteni. Magyarán a néhány
kódsorral megoldható problémára is megpróbálnak ráhúzni valamilyen tervezési mintát, ami természetesen
a kódbázis indokolatlan megnövekedéséhez vezet. Megítélni a minták használatának szükségességét
jelentõs fejlesztõi tapasztalatot igényel.

A State tervezési minta egy viselkedési minta, melynek célja az objektum viselkedésének megváltoztatása
abban az esetben, ha a belsõ állapota módosul\cite{StatePattern}. Tehát feladata függõséget létrehozni
az objektum viselkedése és állapota között.

Ez a minta mindezt egy objektumorientált állapotgép implementálásával valósítja meg. Egymástól független
állapot objektumokat definiál, melyek egy-egy állapothoz köthetõ viselkedést implementálnak.
Ennek megfelelõen az állapottal rendelkezõ objektum az állapot-specifikus viselkedést a kurrens
állapotra delegálja, melyet egy absztrakt õs objektumra mutató pointerrel ér el, kihasználva a C++
nyelv polimorfizmusa által nyújtotta lehetõségeket.

Ami a mintában részt vevõ objektumokat illeti, definiálni kell egy \textit{Context} osztályt,
mely az állapottal rendelkezõ objektumot testesíti meg. Emellett létre kell hozni a már korábban
is említett absztrakt \textit{State} osztályt, mely a konkrét állapotobjektumok közös õse lesz. Ennek
megfelelõen a konkrét állapotokat a \textit{State} osztály leszármazottaiként kell definiálni.
Ezek után már csak a C++ nyelv polimorfizmusát kell használni, miszerint a \textit{Context} osztály tagjaként
el kell tárolni egy \textit{State}-re mutató pointert, melynek a mutatott értékét futás közben tetszõlegesen
állíthatjuk bármilyen \textit{State}-bõl leszármazó osztályra (\figref{StatePatternClassDiagram} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/state_static_diagram.png}
\caption{A State tervezési minta UML osztálydiagrammja}
\label{fig:StatePatternClassDiagram}
\end{figure}

%----------------------------------------------------------------------------
\subsection{Generikus implementáció}
%----------------------------------------------------------------------------
Az elõzõ megoldás alternatívájaként egy olyan megközelítés is bekerült a motorba, mely közelebb áll
a korábban említett véges automaták mûködéséhez. Ez az implementáció mindössze egyetlen generikus
osztályt tartalmaz, melynek neve FiniteStateMachine, ezzel is utalva a már említett véges matematikai
fogalomra.

Az osztály sablon paraméterben kapja meg a kezelendõ állapotok típusát illetve az automata bemeneteinek
típusát. Emellett definiálja azokat a típusokat, melyekkel meg lehet adni, hogy egy adott konkrét automata
az állapotokban való tartózkodást illetve az állapotátmeneteket hogyan kezelje. Az osztály mûködésének
egyik sarkallatos pontja a bemenetek kezelése. Ennek lényege, hogy az aktuális állapothoz megkeresi
a belõle kiinduló átmeneteket, s ezek között megkeresi, hogy melyik aktiválódik az olvasott bemenet
hatására. A megoldásnak Update függvénye is van, mely minden frame-ben meghívódik, s a kurrens állapot
állapotfüggvényeit hívja meg.

%----------------------------------------------------------------------------
\section{Animációs rendszer}
%----------------------------------------------------------------------------
A mai játékokban gyakorlatilag bármilyen játékobjektum rendelkezik legalább egy minimális szintû
animációval. Ezen animációk elsõdleges feladata az objektumok mozgásainak minél élethûbb bemutatása.
Emellett az animációknak információközlõ feladatai is lehetnek, hiszen egy gondosan felépített karakter
animációi kifejezõbbek -- és emellett egyértelmûbbek, illetve könnyebbek értelmezhetõek -- lehetnek,
mint a hangok, feliratok és egyéb információközlõ formák.

Az animációk minõsége tehát nagyban meghatározza a játékról alkotott véleményeket, így a játék minõsítésére,
sikerességére is van befolyásuk. Nem véletlen, hogy a nagy játékfejlesztõ cégek rengeteg pénzt és
energiát fordítanak a minél élethûbb és részletgazdagabb animációk elõállítására (pl.: motion capture).

Az én rendszeremben is implementáltam animációkkal összefüggõ funkciókat, melyek a State tervezési mintára
illetve az állapotgépes megközelítésre építenek. A továbbiakban ezen megoldások bemutatása következik.

%----------------------------------------------------------------------------
\subsection{Csontváz alapú animáció megvalósítása a State tervezési minta felhasználásával}
%----------------------------------------------------------------------------
Ez az implementáció analógia a State tervezési mintánál leírtakra. A továbbiakban az ott ismertetett
objektumoknak megfeleltethetõ játékmotor oldali megoldások bemutatása következik.

A State tervezési minta State osztályának a játékmotor IState osztálya felel meg. Ahogy ennek az osztálynak a neve is sugallja, egy interfészrõl van szó, melynek három fõ absztrakt függvénye van:
az Enter függvény az állapotba lépés legelején, egyszer fut le, az Execute függvény minden frame-ben
lefut, s az Exit pedig szintén egyszer fut le, mégpedig az állapotból való kilépéskor. Konkrét állapotok
létrehozásához ebbõl az osztályból kell leszármazott osztályokat készítenie a felhasználónak, s a megfelelõ
funkciókat az imént ismertetett függvények felüldefiniálásával adhatja meg.

A State minta ismertetésénél bemutatott Context osztálynak a játékmotor Stateable osztálya felel meg.
Ez az osztály tagváltozóként eltárolja a kurrens állapotát, melyet lecserélhet, illetve befrissítõ
függvényében meghívhatja annak Execute függvényét.

Játékmotor oldalon még egyetlen osztály, az AnimState képviseli ezt a megoldást, amely az IState osztály
leszármazottja. Ez az osztály tetszõleges számú Ogre::AnimationState-et képes eltárolni magában (csak a
számítógép tárkapacitása szabhat határt). A szokásos getter-setter függvények mellett az osztály
rendelkezik egy Blend függvénnyel, mely az animációk közötti átmenetet valósítja meg lineáris
interpoláció segítségével.

A megoldás használatához játéklogika-oldalon definiálni kell egy Stateable leszármazottat illetve
tetszõleges számú AnimState leszármazottat (melyek lehetõség szerint singleton objektumok), mely
leszármazottak egymás között döntik el, hogy a hozzájuk tartozó Stateable leszármazottnak mikor melyikük
legyen az aktuális állapota.

%----------------------------------------------------------------------------
\subsection{Csontváz alapú animáció megvalósítása állapotgéppel}
%----------------------------------------------------------------------------
Ahhoz, hogy a felhasználónak ne kelljen közvetlenül az Ogre animációs rendszerét használnia,
létrehoztam egy olyan komponenst motor oldalon, melynek az a feladata, hogy gyakran használt,
animációkhoz kötõdõ mûveleteket nyújtson a felhasználók felé. Természetesen ezen mûveletek
implementációi továbbhívnak az Ogre animációs rendszerébe, viszont ennek köszönhetõen a programozóknak
már ezt nem kell megtenniük, nekik elég ezt az absztrahált interfészt használniuk.

A korábban taglalt állapotgép implementációmhoz ez úgy kapcsolódik, hogy a felhasználó játék oldalon
definiál egy AnimationComponent leszármazottat, s ennek a leszármazottnak a tagváltozójaként veheti fel
azt az egy vagy több állapotgépet, melyek a konkrét animációs állapotokat és átmeneteiket reprezentálják.

%----------------------------------------------------------------------------
\subsection{Animációs megoldások összehasonlítása}
%----------------------------------------------------------------------------
A State tervezési mintán alapuló megoldásnak egyértelmû elõnye az állapotgépes megoldáshoz képest az
animációs állapotok interpolálása állapotváltás esetén. Ennek köszönhetõen az így animált karakterek
mozgása folytonosabbnak, ezáltal életszerûbbnek hat a felhasználók számára.

Ennek ellenére természetesen az állapotgépes megoldásnak is megvan a maga elõnye a másik megoldással
szemben, mégpedig az, hogy az állapotokat leíró függvények és az állapotátmeneteket definiáló függvények
kódjai jól elkülönülnek kód szinten, ennek köszönhetõen bonyolultabb állapotgráf
reprezentálására ez a megoldás alkalmasabb, mint a State mintán alapuló implementáció.

Mivel egyik megoldást sem tudtam egyértelmûen a jobbnak nevezni a másiknál, így mindkét implementáció
a motor részét képezi, s a felhasználó dönthet arról, hogy melyik megoldást választja a saját feladatai
elvégzéséhez.

%----------------------------------------------------------------------------
\section{Felhasználói felület}
%----------------------------------------------------------------------------
A felhasználói felületek használata a mai játékokban alap funkcionalitásnak tekinthetõ, hiszen még
egy kisebb mobil alkalmazásnak is nyújtania kell valamiféle GUI-t a felhasználó felé, hogy tájékoztassa
õt a legfontosabb adatokról (pl.: játékos életereje), lehetõséget adjon neki a játékmenetbe történõ
beavatkozásra (pl.: fegyver felvétele), vagy éppen megváltoztassa az alkalmazás használatának módját
(pl.: gombok jelentése, hangerõ szabályozása).

Ezen felsorolt jellemzõi miatt az én rendszeremben is megvalósítottam egy GUI rendszert a MyGUI
felhasználásával, melyet a továbbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{MyGUI ismertetése}
%----------------------------------------------------------------------------
A MyGUI egy nyílt forrású, ingyenes, multiplatform GUI keretrendszer, mely MIT licensz alatt fut.
Gyorsasága és egyszerûsége ellenére igen komplex felhasználói felületek kialakítására is alkalmas.
Hátrányaként felróható, hogy a dolgozat írásának idején a legfrissebb stabil verziója (3.2.2) 2015 január
26.-án jelent meg, tehát az eszközt fejlesztõ közösség nem mutat túlzott aktivitást.
Ennek ellenére számos OGRE-s projektben került már felhasználásra, ezért esett rá a választásom.

Az eszköz használatának kierõszakolása viszont nem volt zökkenõmentes. A szokásos CMake-es kitérõk
mellett valamiért a program DirectX használata mellett nem volt hajlandó mûködni. Ennek az volt az
oka, hogy az általam használt OGRE verzió (1.9) már a DirectX11-et használja, amelyben viszont már
nincs fixed function pipeline, vagyis a keretrendszer már nem kínál alapértelmezett árnyalóprogramokat
a felhasználók számára. Hosszas debuggolási folyamat végén derült csak ki, hogy ezért a hibáért
a MyGUI is felelõs, hiszen neki is vannak saját material-jai, melye(ke)t saját magának, belül állít
össze, támaszkodva a rendszer alap árnyalóprogramjaira. A hiba javítása helyett áttértem a GLSL
használatára, mellyel egy újabb lépést tettem a multiplatformság felé.

A probléma megoldása után a motor oldali GUI rendszert a GUI szkriptek használatának irányába
fejlesztettem.

<KÉPERNYÕKÉPEK!!!>

%----------------------------------------------------------------------------
 \section{Hangrendszer}
%----------------------------------------------------------------------------
A hangok használata a mai játékokban messze túlmutat a felhasználó szórakoztatásán, hiszen emellett egyéb
céljai is vannak, mint például az aktuális játékbeli szituációhoz kapcsolódó
hangulat sugallása illetve felerõsítése, földrajzi elhelyezkedés ismertetése, a játékost megszemélyesítõ
karakter (vagyis az avatar) jellemzése, vagy éppen a játékos aktuális cselekvésének sikerességét is
szokás hangokkal jelezni a felhasználó felé (pl.: fegyver felvétele, szintlépés, stb.).

Összességében az elmondható, hogy a megfelelõen megválasztott és idõzített hangokkal hatni lehet a
felhasználók lelki világára illetve hangulatára, emellett informálják õket a státuszukról, az aktuális környezetrõl illetve az elõrehaladásukról is, s ezen tulajdonságaik miatt a mai játékok elengedhetetlen kellékei.

Az elõbb felsorolt jellemzõk miatt az én megoldásomból sem hiányozhat egy saját hangrendszer implementálása,
melyet az alábbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{Megvalósítás}
%----------------------------------------------------------------------------
A megvalósításhoz az ingyenes, platformfüggetlen OpenAL-t használtam fel, mely az OpenGL 
hang-analógiájának is tekinthetõ, legalábbis ami az API felépítését tekinti. Állapotgép!!!

Az implementáció ismertetéséhez szükség van néhány OpenAL-hez kapcsolódó fogalom tisztázására, melyeket
a következõkben ismertetek.

A listener az a térbeli objektum, melynek a szemszögébõl rendereljük a hangforrásokat (pongyolán
fogalmazva ez a kamera füle). A definíciójából adódik, hogy egyidõben csak egyetlen ilyen
objektumnak kell léteznie, jelenettõl függetlenül.

A buffer objektum megfeleltethetõ egy olyan leíró fájlnak, mely egy hangfájl adatait 
tartalmazza. Ilyen típusú objektumból akárhányat fel lehet használni.

A source olyan objektum, mely egy vagy több buffer lejátszását teszi lehetõvé. Több source-hoz is
hozzá lehet rendelni ugyan azt a buffert, viszont egy source egyszerre csak egyetlen buffer tartalmát
képes emittálni. Ebbõl már nem lehet
egyszerre akármennyi a rendszerben, hiszen a hangkártyák hardveres limitációi ezt nem teszik lehetõvé.
Az én megoldásomban maximum 16 buffer tartalmát lehet lejátszani egyidõben, így a megoldásom régebbi
hangkártyákkal is kompatibilis.
A forrás objektumokkal kapcsolatban megjegyzendõ, hogy lehetnek 2D-sek (Music vagy Ambient)
illetve 3D-sek (SoundEffect) is. Az elõbbi
azt jelenti, hogy a listenertõl való távolsága mindig nulla, míg értelemszerûen ez a 3D-s esetben nem
igaz. A háromdimenziós (azaz térbeli) hangoknál a valósághûbb hangérzet elérésének érdekében a
hangmagasságot megperturbálom egy általam megválasztott random faktorral. A további valósághû érzet
keltése érdekében nem csak a hangmagasságot, hanem a kiválaszott buffert is randomizálhatja a felhasználó,
ha akarja (de dönthet úgy is, hogy a source-hoz rendelt buffereket sorrendhelyesen akarja lejátszani).
Ennek implementálásához ki kellett vennem a rendszerbõl az OpenAL beépített looping funkcionalitását,
ugyanis az a bufferek cserélgetését nem hordozza magában.

A megvalósításhoz két osztályt definiáltam motor oldalon. Az egyik az AudioManager, melynek feladata
a source-ok, a bufferek és a listener menedzselése és karbantartása. A másik objektum az
AudioSourceComponent, mely szabad source-ot és tetszõleges számú buffert kérhet az AudioManager-tõl,
s lejátszhatja a hozzá rendelt buffereket tetszõleges számú alkalommal, a korábban említett módokon.
Ha az AudioManager nem tud adni az AudioSourceComponent-nek szabad source-ot, akkor a lejátszás
egyszerûen nem történik meg, de a rendszerben attól még megjelenik az igény.
Az AudioManager tehát tetszõleges számú AudioSourceComponent-et menedzsel, s minden frame-ben
felállít köztük egy sorrendiséget a következõk szerint: legelõre veszi a Music típusú komponenseket,
aztán az Ambient típusúak következnek, végül pedig a SoundEffect-ek maradnak, melyek közötti sorrendet
a listenertõl való távolság határozza meg (a közelebbi kerül elõrébb a sorban).
Az így berendezett tároló elsõ 16 eleme OpenAL source-hoz jut, a többi pedig várakozni kényszerül.

<DIAGRAMOK!!!>

%----------------------------------------------------------------------------
\section{Plakátok és részecskerendszerek}
%----------------------------------------------------------------------------
Nem volt igény kód oldali reprezentációra, mindössze annyiból áll az implementáció, hogy egy
speciális motor oldali komponens (ParticleComponent) képes beparszolni illetve leállítani/újraindítani
egy Ogre ParticleScriptet. Ez a megoldás azért elõnyös, mert a részecskerendszer módosulása esetén
nem kell újrafordítani a forráskódot. Emellett viszont ez a megközelítés nem teszi lehetõvé
részecskerendszerek kódból történõ módosítását vagy akár létrehozását.

talan lehetne felhozni itt egy pl scriptet?
%----------------------------------------------------------------------------
\section{Egyéb}
%----------------------------------------------------------------------------
Delegate

%----------------------------------------------------------------------------
\section{Áttekintés}
%----------------------------------------------------------------------------

<DIAGRAMOK!!!>
