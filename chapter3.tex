%----------------------------------------------------------------------------
\chapter{A játékmotor bõvítése}
%----------------------------------------------------------------------------
Ez a fejezet tartalmazza a Bevezetõ fejezetben ismertetett feladataimnak a megoldásait.

Elsõként bemutatja a játékobjektumok késleltetett létrehozásának megvalósítását, aztán az
állapotgép alapú rendszerek taglalását követõen az animációs alrendszer és a mesterséges intelligencia
alrendszer implementálását ismerteti. Ezt követõen részletezi a felhasználói felület létrehozásának módját.
Végezetül a fejezet a -- már alapjaiben eddig is meglevõ -- hangrendszer illetve részecskerendszer
továbbfejlesztésével illetve az elkészült rendszer áttekintésével zárul.

%----------------------------------------------------------------------------
\section{Játékobjektumok késleltetett létrehozása}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Motiváció}
%----------------------------------------------------------------------------
Korábban az XML parszolás azt határozta meg, hogy milyen legyen a betöltött virtuális világ a
kezdeti idõpontjában. Nem volt lehetõség olyan objektumok definiálására, melyek példányosítását
csak a virtuális világ egy késõbbi szakaszában lehetett volna véghez vinni.

Igény viszont lett volna erre a funkcionalitásra, gondoljunk csak egy lõfegyverre, mely valamilyen
lövedéket képes magából kibocsátani egy adott esemény -- például bal egérgomb lenyomása -- hatására.
A lövedék leírásának természetesen helye van az XML leíró fájlban, mégsem szeretnénk, ha az azonnal
betöltõdne. Persze azt sem tudhatjuk, hogy hány példányt definiáljunk a leíró fájlban, mert ez
kizárólag a felhasználótól függ. Viszont azt sem szeretnénk, ha minden lövedék-betöltés elõtt az XML
fájlhoz kellene fordulni, mert az nagyon lelassítaná a program futását (a háttértár elérési ideje
nagyságrendekkel nagyobb a memória elérési idejénél).

Másfelõl annak is van értelme, ha több féle lövedék típus létezik egy játékban, s ezeknek vannak közös
tulajdonságaik. Ebben az esetben is hasznos lenne egy olyan absztrakt játékobjektum definíció
az XML leírásban, melyet közvetlenül nem példányosítunk, viszont a tartalmát felhasználva
-- esetleg azt módosítva -- konkrét játékobjektumokat lehet létrehozni.

Ezen igények kielégítésére találták ki a prefab-okat, melyek implementálását a saját rendszeremben
az alábbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{Megvalósítás}
%----------------------------------------------------------------------------
Mindezen funkcionalitások megvalósítására lehetõvé tettem a motorom számára a játékobjektumok
késleltetett létrehozását. A megvalósításnak a lényege, hogy minden komponenshez definiálok egy-egy
leíró struktúrát, mely tartalmazza az összes olyan paramétert, mely átadható a hozzá tartozó
komponensnek. A leíró struktúrák mellett létrehoztam egy \textit{GenericPrefab} nevû generikus osztályt,
melynek feladata adott típusú létrehozó struktúra feltöltése és alkalmazása adott típusú komponensre.
A \textit{GenericPrefab} osztály a nem generikus \textit{IPrefab} interfészbõl származik le, melynek
a legfõbb létjogosultsága, hogy segítségével a különbözõ \textit{GenericPrefab} példányok
eltárolhatók heterogén kollekcióban. Az összetartozó \textit{GenericPrefab} példányokat
\textit{GameObjectCreator} példányban tárolom, melybõl szükség szerint lehet \textit{GameObject}
példányokat gyártani. A \textit{GameObjectCreator} objektumok az \textit{ObjectManager}-ben
foglalnak helyet.

Ezen módosítások mellett módosítanom kellett a komponensek XML-bõl történõ beolvasásáért felelõs
osztályokat is. A korábbiakkal ellentétben ugyanis ezek az objektumok már nem konkrét komponens
leszármazottakat, hanem \textit{GenericPrefab}-okat hoznak létre. Szükség esetén természetesen
a \textit{GenericPrefab} példányból azonnal lehet komponens leszármazottat is készíteni, tehát a régi
funkcionalitás nem vész el. Viszont bõvül azzal, hogy a \textit{GenericPrefab} példányt elrakhatom egy
\textit{GameObjectCreator}-ba egy -- vagy több -- késõbbi használat reményében.

<DIAGRAM(OK)>

%----------------------------------------------------------------------------
\section{Állapotgép alapú rendszerek}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Az állapotgépekrõl általánosságban}
%----------------------------------------------------------------------------
Az állapotgépek - vagy ahogy a diszkrét matematika nevezi: véges automaták - véges állapothalmazzal
rendelkezõ absztrakt gépek. Definiálásához meg kell adni az állapotok halmazát, a kezdõ állapotot,
az ``elfogadó'' állapotok halmazát (ami a teljes állapothalmaz részhalmaza), az automata ábécéjét
(vagyis azt a halmazt, ami fölött értelmezve vannak az automata lehetséges bemenetei), illetve az
állapotátmeneti függvényeket, amik egy állapot-bemenet pároshoz egy állapotot rendelnek (vagyis ezek
a függvények megmondják, hogy ha egy adott állapotban egy adott input érkezik, akkor mely állapotba
kell átmennie az automatának).

Egy ilyen gép mûködése a következõ: adott egy véges hosszú input szalag illetve egy olvasófej,
mely kezdetben a szalag bal szélén helyezkedik el, s csak jobbra tud lépni. Az automata az aktuálisan
olvasott input és az állapotátmeneti függvények ismeretében minden lépésben meghatározza a saját következõ
állapotát. Ha az olvasófej az input végére ért, akkor két eset lehetséges: ha akkor elfogadó állapotba
ment át az automata, akkor az automata elfogadja a bemenetét, különben nem fogadja el.
%----------------------------------------------------------------------------
\subsection{A State tervezési minta}
%----------------------------------------------------------------------------
A tervezési minták gyakran elõforduló szoftverfejlesztési problémákra adnak
egy -- az ipar által elfogadott -- megoldást. Ez elsõre különösen hangozhat, hiszen egy
probléma megoldásának számos módja lehet egy adott programozási nyelven, miért van szükség
egyetlen megoldás kiemelésére? Természetesen ezek a megoldások csak ajánlások, használatukra nyílván
nem is lehetne kötelezni a programozókat, ráadásul ezek az ajánlott megoldások esetenként nem is
jelentik a ``legjobb'' megoldást a felmerülõ problémáinkra, ennek ellenére ezeknek a mintáknak
a használata -- az ismertségük miatt -- mindenképpen ajánlott. A használatot ebben az esetben nem úgy
kell érteni, hogy teljes mértékben azt valósítjuk meg, amit a minta állít, hanem hogy a minta által
sugallt megoldási ötletet felhasználva készítjük el az implementációt. Ha így járunk el, akkor a
tervezési mintákat ismerõ fejlesztõk könnyebben és így gyorsabban tudják értelmezni a kódjainkat.
Ehhez kapcsolódóan megjegyzendõ, hogy  -- fõleg tapasztalatlan fejlesztõk körében -- nem a minták
ignorálása, hanem épp ellenkezõleg, a minták túlhasználása szokta a gondot jelenteni. Magyarán a néhány
kódsorral megoldható problémára is megpróbálnak ráhúzni valamilyen tervezési mintát, ami természetesen
a kódbázis indokolatlan megnövekedéséhez vezet. Megítélni a minták használatának szükségességét
jelentõs fejlesztõi tapasztalatot igényel.

A State tervezési minta egy viselkedési minta, melynek célja az objektum viselkedésének megváltoztatása
abban az esetben, ha a belsõ állapota módosul\cite{StatePattern}. Tehát feladata függõséget létrehozni
az objektum viselkedése és állapota között.

Ez a minta mindezt egy objektumorientált állapotgép implementálásával valósítja meg. Egymástól független
állapot objektumokat definiál, melyek egy-egy állapothoz köthetõ viselkedést implementálnak.
Ennek megfelelõen az állapottal rendelkezõ objektum az állapot-specifikus viselkedést a kurrens
állapotra delegálja, melyet egy absztrakt õs objektumra mutató pointerrel ér el, kihasználva a C++
nyelv polimorfizmusa által nyújtotta lehetõségeket.

Ami a mintában részt vevõ objektumokat illeti, definiálni kell egy \textit{Context} osztályt,
mely az állapottal rendelkezõ objektumot testesíti meg. Emellett létre kell hozni a már korábban
is említett absztrakt \textit{State} osztályt, mely a konkrét állapotobjektumok közös õse lesz. Ennek
megfelelõen a konkrét állapotokat a \textit{State} osztály leszármazottaiként kell definiálni.
Ezek után már csak a C++ nyelv polimorfizmusát kell használni, miszerint a \textit{Context} osztály tagjaként
el kell tárolni egy \textit{State}-re mutató pointert, melynek a mutatott értékét futás közben tetszõlegesen
állíthatjuk bármilyen \textit{State}-bõl leszármazó osztályra (\figref{StatePatternClassDiagram} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/state_static_diagram.png}
\caption{A State tervezési minta UML osztálydiagrammja}
\label{fig:StatePatternClassDiagram}
\end{figure}

%----------------------------------------------------------------------------
\subsection{Generikus implementáció}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\section{Animációs alrendszer}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Animációk típusai}
%----------------------------------------------------------------------------
skeleton animacio, inverz kinematika, eloremeno kinematika, kulcskeret animacio...
a 3DGraf konyv sokat segit (es mashol is)

%----------------------------------------------------------------------------
\subsection{Az OGRE animációs rendszerének mûködése}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Csontváz animáció megvalósítása}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\section{Felhasználói felület}
%----------------------------------------------------------------------------
A felhasználói felületek használata a mai játékokban alap funkcionalitásnak tekinthetõ, hiszen még
egy kisebb mobil alkalmazásnak is nyújtania kell valamiféle GUI-t a felhasználó felé, hogy tájékoztassa
õt a legfontosabb adatokról (pl.: játékos életereje), lehetõséget adjon neki a játékmenetbe történõ
beavatkozásra (pl.: fegyver felvétele), vagy éppen megváltoztassa az alkalmazás használatának módját
(pl.: gombok jelentése, hangerõ szabályozása).

Ezen felsorolt jellemzõi miatt az én rendszeremben is megvalósítottam egy GUI rendszert a MyGUI
felhasználásával, melyet a továbbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{MyGUI ismertetése}
%----------------------------------------------------------------------------
A MyGUI egy nyílt forrású, ingyenes, multiplatform GUI keretrendszer, mely MIT licensz alatt fut.
Gyorsasága és egyszerûsége ellenére igen komplex felhasználói felületek kialakítására is alkalmas.
Hátrányaként felróható, hogy a dolgozat írásának idején a legfrissebb stabil verziója (3.2.2) 2015 január
26.-án jelent meg, tehát az eszközt fejlesztõ közösség nem mutat túlzott aktivitást.
Ennek ellenére számos OGRE-s projektben került már felhasználásra, ezért esett rá a választásom.

Az eszköz használatának kierõszakolása viszont nem volt zökkenõmentes. A szokásos CMake-es kitérõk
mellett valamiért a program DirectX használata mellett nem volt hajlandó mûködni. Ennek az volt az
oka, hogy az általam használt OGRE verzió (1.9) már a DirectX11-et használja, amelyben viszont már
nincs fixed function pipeline, vagyis a keretrendszer már nem kínál alapértelmezett árnyalóprogramokat
a felhasználók számára. Hosszas debuggolási folyamat végén derült csak ki, hogy ezért a hibáért
a MyGUI is felelõs, hiszen neki is vannak saját material-jai, melye(ke)t saját magának, belül állít
össze, támaszkodva a rendszer alap árnyalóprogramjaira. A hiba javítása helyett áttértem a GLSL
használatára, mellyel egy újabb lépést tettem a multiplatformság felé.

A probléma megoldása után a motor oldali GUI rendszert a GUI szkriptek használatának irányába
fejlesztettem.

<KÉPERNYÕKÉPEK!!!>

%----------------------------------------------------------------------------
 \section{Hangrendszer}
%----------------------------------------------------------------------------
A hangok használata a mai játékokban messze túlmutat a felhasználó szórakoztatásán, hiszen emellett egyéb
céljai is vannak, mint például az aktuális játékbeli szituációhoz kapcsolódó
hangulat sugallása illetve felerõsítése, földrajzi elhelyezkedés ismertetése, a játékost megszemélyesítõ
karakter (vagyis az avatar) jellemzése, vagy éppen a játékos aktuális cselekvésének sikerességét is
szokás hangokkal jelezni a felhasználó felé (pl.: fegyver felvétele, szintlépés, stb.).

Összességében az elmondható, hogy a megfelelõen megválasztott és idõzített hangokkal hatni lehet a
felhasználók lelki világára illetve hangulatára, emellett informálják õket a státuszukról, az aktuális környezetrõl illetve az elõrehaladásukról is, s ezen tulajdonságaik miatt a mai játékok elengedhetetlen kellékei.

Az elõbb felsorolt jellemzõk miatt az én megoldásomból sem hiányozhat egy saját hangrendszer implementálása,
melyet az alábbiakban ismertetek.

%----------------------------------------------------------------------------
\subsection{Megvalósítás}
%----------------------------------------------------------------------------
A megvalósításhoz az ingyenes, platformfüggetlen OpenAL-t használtam fel, mely az OpenGL 
hang-analógiájának is tekinthetõ, legalábbis ami az API felépítését tekinti. Állapotgép!!!

Az implementáció ismertetéséhez szükség van néhány OpenAL-hez kapcsolódó fogalom tisztázására, melyeket
a következõkben ismertetek.

A listener az a térbeli objektum, melynek a szemszögébõl rendereljük a hangforrásokat (pongyolán
fogalmazva ez a kamera füle). A definíciójából adódik, hogy egyidõben csak egyetlen ilyen
objektumnak kell léteznie, jelenettõl függetlenül.

A buffer objektum megfeleltethetõ egy olyan leíró fájlnak, mely egy hangfájl adatait 
tartalmazza. Ilyen típusú objektumból akárhányat fel lehet használni.

A source olyan objektum, mely egy vagy több buffer lejátszását teszi lehetõvé. Több source-hoz is
hozzá lehet rendelni ugyan azt a buffert, viszont egy source egyszerre csak egyetlen buffer tartalmát
képes emittálni. Ebbõl már nem lehet
egyszerre akármennyi a rendszerben, hiszen a hangkártyák hardveres limitációi ezt nem teszik lehetõvé.
Az én megoldásomban maximum 16 buffer tartalmát lehet lejátszani egyidõben, így a megoldásom régebbi
hangkártyákkal is kompatibilis.
A forrás objektumokkal kapcsolatban megjegyzendõ, hogy lehetnek 2D-sek (Music vagy Ambient)
illetve 3D-sek (SoundEffect) is. Az elõbbi
azt jelenti, hogy a listenertõl való távolsága mindig nulla, míg értelemszerûen ez a 3D-s esetben nem
igaz. A háromdimenziós (azaz térbeli) hangoknál a valósághûbb hangérzet elérésének érdekében a
hangmagasságot megperturbálom egy általam megválasztott random faktorral. A további valósághû érzet
keltése érdekében nem csak a hangmagasságot, hanem a kiválaszott buffert is randomizálhatja a felhasználó,
ha akarja (de dönthet úgy is, hogy a source-hoz rendelt buffereket sorrendhelyesen akarja lejátszani).
Ennek implementálásához ki kellett vennem a rendszerbõl az OpenAL beépített looping funkcionalitását,
ugyanis az a bufferek cserélgetését nem hordozza magában.

A megvalósításhoz két osztályt definiáltam motor oldalon. Az egyik az AudioManager, melynek feladata
a source-ok, a bufferek és a listener menedzselése és karbantartása. A másik objektum az
AudioSourceComponent, mely szabad source-ot és tetszõleges számú buffert kérhet az AudioManager-tõl,
s lejátszhatja a hozzá rendelt buffereket tetszõleges számú alkalommal, a korábban említett módokon.
Ha az AudioManager nem tud adni az AudioSourceComponent-nek szabad source-ot, akkor a lejátszás
egyszerûen nem történik meg, de a rendszerben attól még megjelenik az igény.
Az AudioManager tehát tetszõleges számú AudioSourceComponent-et menedzsel, s minden frame-ben
felállít köztük egy sorrendiséget a következõk szerint: legelõre veszi a Music típusú komponenseket,
aztán az Ambient típusúak következnek, végül pedig a SoundEffect-ek maradnak, melyek közötti sorrendet
a listenertõl való távolság határozza meg (a közelebbi kerül elõrébb a sorban).
Az így berendezett tároló elsõ 16 eleme OpenAL source-hoz jut, a többi pedig várakozni kényszerül.

<DIAGRAMOK!!!>

%----------------------------------------------------------------------------
\section{Plakátok és részecskerendszerek}
%----------------------------------------------------------------------------
Nem volt igény kód oldali reprezentációra, mindössze annyiból áll az implementáció, hogy egy
speciális motor oldali komponens (ParticleComponent) képes beparszolni illetve leállítani/újraindítani
egy Ogre ParticleScriptet. Ez a megoldás azért elõnyös, mert a részecskerendszer módosulása esetén
nem kell újrafordítani a forráskódot. Emellett viszont ez a megközelítés nem teszi lehetõvé
részecskerendszerek kódból történõ módosítását vagy akár létrehozását.

talan lehetne felhozni itt egy pl scriptet?
%----------------------------------------------------------------------------
\section{Egyéb}
%----------------------------------------------------------------------------
Delegate

%----------------------------------------------------------------------------
\section{Áttekintés}
%----------------------------------------------------------------------------

<DIAGRAMOK!!!>
