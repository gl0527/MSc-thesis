%----------------------------------------------------------------------------
\chapter{A keretrendszer átdolgozása}
%----------------------------------------------------------------------------
Az alábbi fejezet bemutatja azokat a módszereket, melyek segítségével módosítottam a szoftverkörnyezet
felépítését annak érdekében, hogy annak build-elési módja, karbantarthatósága illetve bõvíthetõsége
javuljon a korábbi rendszerhez képest.

%----------------------------------------------------------------------------
\section{Projektek build-elése}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Build-elési idõ csökkentése}
%----------------------------------------------------------------------------
C++ projektek esetében nem lehet figyelmen kívül hagyni a build-elési idõ hosszát, hiszen ez az
egyik leglassabban build-elõ programozási nyelv, ami a komplexitásából adódik. Korábbi munkáim
során nem törõdtem ezzel a metrikával, hiszen a projektek mérete és bonyolultsága miatt az
újrabuild-elések ideje sem volt számottevõ, viszont a szakdolgozatom eredményeként megszületett
szoftverre ezt nem lehetett elmondani. A fejlesztési idõ vége felé kifejezetten hosszú ideig tartott
egy-egy kisebb módosítás utáni build-elés ideje is, ezért határoztam el azt, hogy idõmet és energiámat
nem sajnálva megpróbálom csökkenteni a build-elési folyamat idejét, hiszen ha ezt nem tenném meg, akkor
a késõbbi -- feltehetõleg nagyobb -- kódbázis esetén a várakozási idõk még hosszabbak lennének.

Az legfontosabb követendõ elv volt számomra a header fájlok szerepének csökkentése. Ez azt
jelenti, hogy minimalizálni kell az \verb+#include+-okat illetve a függvény definíciókat ezekben
a fájlokban. Mindez azért hasznos, mert így csökkenthetõ a header fájlok változási gyakorisága, így
ritkábban kell azokat illetve az azokat használó fájlokat újrafordítani. Tehát egy source fájlban
történõ változás sokkal ``olcsóbb'', mint egy header-beli változás, mivel a source fájlt nem 
\verb+#include+-olja senki, így a változása nem érint más fájlokat.

A header fájlokban levõ \verb+#include+-ok számának minimalizálására egy bevált módszer az elõdeklarálás
módszere. Ennek az a lényege, hogy ha egy header fájlban használok egy szimbólum nevet (pl.: egy osztály
neve), viszont nem használom annak definícióját (pl.: egy osztály tagfüggvényét), akkor igazából
abban a fájlban nincs is szükség a használt szimbólum definíciójára, csak a nevének elõdeklarálására.
Ebben az esetben a tényleges definíció használata -- tehát a tényleges \verb+#include+-olás -- a source
fájlban történik meg. Megjegyzendõ, hogy ez a módszer hatékonyan használható a körkörös dependenciák
problémájának feloldására is. Mindezeken túl a dependenciák számának kordában tartására is megfelelõ
módszer az \verb+#include+-ok számának minimalizálása, hiszen gondoljunk csak bele, ha egy header
fájlt valamely kódrészbe beemelek, akkor nem csak annak a tartalma, hanem az õ \verb+#include+
fájljainak a tartalma is beemelõdik, és így tovább, tranzitív módon. Így könnyen elõfordulhat, hogy
a ténylegesen beemelt kódmennyiségnek csak a töredékét szeretnénk ténylegesen használni.

\begin{lstlisting}[frame=single,float=!ht,
caption={Példa elõdeklarálásra a C++ nyelvben}, label=ForwardDeclarationCpp]
// forward declaration of class A
class A;
class B
{
	A* pA;	// there is no need for the definition of class A
};
\end{lstlisting}

Egy másik technika is a header fájlokhoz köthetõ, miszerint használjunk include guard-okat. Ennek
a techikának a lényege, hogy a header tartalmát a compiler csak akkor parszolja be, ha azt még nem
tette meg. Ezt header fájlonként külön makrók definiálásával tehetjük meg. Modernebb fordítók többsége
támogatja a \verb+#pragma once+ preprocesszor direktívát is (annak ellenére, hogy ez nem a szabvány része),
melynek használatával ugyan azt az eredményt lehet elérni, mint az include guard-os makrók definiálásával.
Az én kódjaimban a két ismertetett megoldást együtt használom, így a kívánt funkcionalitást olyan
fordítók esetén is el tudom érni, melyek nem támogatják a \verb+#pragma once+ használatát.

\begin{lstlisting}[frame=single,float=!ht,
caption={Include guard és pragma once együttes használata}, label=IncludeGuardsCpp]
#ifndef INCLUDE_GUARD
#define INCLUDE_GUARD

#pragma once

/* header content goes here */

#endif
\end{lstlisting}

Az imént említett módszerek mellett népszerû megoldás az elõfordított header fájlok használata is.
Ennek a technikának az a lényege, hogy létrehozunk egy olyan header fájlt, melyben az olyan
\verb+#include+-olások szerepelnek, melyek nagy méretûek, sok helyen kell használni õket illetve
soha -- vagy csak nagyon ritkán -- változnak. Ennek a fájlnak a létrehozása után megmondhatjuk
a kurrens fordítónak -- ha az támogatja --, hogy kezelje ezt a header fájlt elõfordítottként, vagyis
ezt fordítsa le elsõnek, és egyetlen egyszer, s linkeléskor a már meglevõ object fájlt kelljen
használni. Ez is tipikusan egy olyan módszer, mellyel esetenként többszörös gyorsulást lehet
elérni az eredeti build-elési módszerhez képest, viszont ha nem megfelelõen használják, akkor
akár többet is árthat, mint használhat.

A felsorolt módszereken kívül természetesen még számos más technika is létezik a C++-os projektek
build-elési idejének csökkentésére, s a lista valószínûleg a jövõben még tovább fog gyarapodni, hiszen
az gyorsításra való igény továbbra is megvan a fejlesztõk körében.
%----------------------------------------------------------------------------
\subsection{Binárisok méreteinek csökkentése}
%----------------------------------------------------------------------------
Mint ahogy arról korábban már írtam, a motort egy dinamikus könyvtárba fordítom bele.
Ahhoz, hogy az egyes motorban implementált funkcionalitások a játéklogika oldalán is elérhetõek legyenek,
explicite meg kell mondani a fordítóprogramnak, hogy azt tegye elérhetõvé a könyvtárt használók számára.
Ezt gyakran úgy szokták megoldani, hogy ha egy osztálynak egy adott függvényére szükség van a könyvtáron
kívül is, akkor az egész osztály kikerül a könyvtár publikus interfészére. Ez gyakran nem túl szerencsés,
ugyanis legtöbbször ezzel a megoldással sok olyan dolgot is kiajánlunk a könyvtár használói számára,
melyekre igazából nincs is szükségük. Ezzel a megközelítéssel éppen ezért indokolatlanul nagyra
lehet növelni a könyvtár méretét.

Ennek a problémának a megoldására minimalizáltam a könyvtárba bekerülõ tartalmat, melynek hatására
a motor mérete 3.35MB-ról 3.29MB-ra, a játék mérete 475KB-ról 290 KB-ra csökkent.

Ezek mellett kijavítottam egy régóta elhúzódó hibát, melynek az volt a kiváltó oka, hogy a Bullet-hez
-- figyelmetlenségem miatt -- statikusan linkeltem a C Runtime-ot, melynek következtében a motoromnál
is rá voltam kényszerülve a statikus linkelésre a linker error-ok elkerülése végett. A példajáték viszont
továbbra is dinamikusan linkelte magához a C Runtime-ot, aminek következtében elõfordulhattak olyan
esetek dinamikus memóriafoglalásnál, mikor pl. a motor oldalon foglalom le a memóriát, de a játék oldalon
próbálom felszabadítani, ami a legjobb esetben is assert-et okoz, mivel a játék egy olyan memóriaterületet
akar felszabadítani, amit nem is lát, mivel másik heap-en lett foglalva.

Ezt -- miután rájöttem a hiba forrására -- már triviális volt kijavítani, hiszen csak a megfelelõ
Bullet-hez tartozó statikus könyvtárakat kellett újrafordítani úgy, hogy dinamikusan linkeljék
magukhoz a C Runtime-ot, majd az engine-re is alkalmazva ezt a beállítást a fentebb említett
problémák megszûntek. A javítás után az engine mérete -- mivel már nem tartalmazta magában a
C Runtime-ot -- lecsökkent 1.8MB-ra.

%----------------------------------------------------------------------------
\subsection{CMake használata}
%----------------------------------------------------------------------------
ide kell minden a cmake-rol

hátha más platformon is mûködne a programom

a visual studio beállításai között matatni sem leányálom + könnyû elrontani
nagy projekteknél ez egyszerûbb, mint mindig kézzel beállítani a dependenciákat a user-eknél

a visual studio nem szemeteli tele a forras konyvtarakat

A projekt könyvtárszerkezetének kialakítása

%----------------------------------------------------------------------------
\section{Jelenetek kezelése}
%----------------------------------------------------------------------------
A szakdolgozatom során implementált megoldásban a jelenet leírása kizárólag a pálya leírására korlátozódott
(tehát például játékobjektumok kezdeti transzformációit nem lehetett benne leírni),
ráadásul azt is csak két dimenziós síkként lehetett értelmezni, ennek megfelelõen bármely leíró fájl
két dimenziós koordinátákat tartalmazott (x, illetve z koordináták).

Természetesen ez a megoldás egyrészt erõsen korlátozza a felhasználó szabadságát a kialakítható jelenet
milyenségében (például a pálya talaja nem lehet tetszõleges domborzat, mindenképp síknak kell lennie),
másrészt összetettebb leírások készítése fáradságos munka, ráadásul ha az eredmény nem
felel meg az elvárásoknak, akkor elég nehéz észrevenni a hiba okát egy hosszadalmas leírásban.

Jelen diplomatervezés során az elõzõtõl teljesen különbözõ megoldást implementáltam, melynek segítségével
a felhasználónak lehetõsége nyílik bonyolultabb jelenetek leírására is.

Ehhez definiáltam egy olyan XML formátumot, mely illeszkedik ahhoz a komponens alapú szemlélethez,
melyet az egész rendszer képvisel. Ez azt jelenti, hogy az XML leírás játékobjektumok leírásainak az
összessége, amely leírások pedig komponensek leírásaiból tevõdnek össze.

Ennek megfelelõen a megvalósítás során komponens parszereket kellett készítenem,
melyek által létrehozott komponenseket a szülõ XML-tag által reprezentált játékobjektumokhoz kell hozzáfûzni.
Így a jelenetleíró XML fájl egyetlen rekurzív top-down bejárásával a felhasználó által leírt jelenet
 -- a megfelelõ komponens parszerek meglétében -- megjelenik a szimuláció kezdetén.
Onnantól kezdve a fizikai világ szabályai illetve a felhasználói események indukálhatják a virtuális
világ változásait.

Az XML parszolásához a TinyXML nevû eszközt használtam fel, amely egy C++-ban írt, platformfüggetlen,
nyílt forráskódú, ingyenes XML feldolgozó könyvtár.

%----------------------------------------------------------------------------
\section{Bemenetek kezelése}
%----------------------------------------------------------------------------
Ezelõtt a bemeneti eszközök eseményeit kizárólag pollingolós módszerrel figyeltem, ami azt jelenti,
hogy minden frame-ben rá kellett néznem a bemeneti eszközök aktuális állapotaira. Ennek a megoldásnak
az az elõnye, hogy mindig pontosan tudom, hogy az update-elési lánc melyik részérõl polling-olok.
A megoldásnak a hátránya viszont az, hogy nem költség-hatékony, hiszen a frame-enkénti ellenõrzés
túl sok fölösleges kommunikációt vihet a rendszerbe.

Ezt a megoldást kiegészítettem azzal, hogy a bemeneti eseményeket figyelõ osztályom (InputManager)
feliratkozik OIS eseményekre, s mint ahogy azt az Observer tervezési mintánál megszokhattuk, bármilyen
bemeneti eszköz-eseményrõl értesítést kap, s meghívódik a megfelelõ eseménykezelõ függvénye. Ennek a
megoldásnak az az elõnye, hogy az eseménykezelõ kód kizárólag akkor hívódik meg, amikor az esemény
bekövetkezett, tehát nincs fölösleges kommunikációs overhead. A megoldás hátrányaként ugyanakkor
megemlíthetõ, hogy nem tudjuk azt, hogy az eseménykezelõ függvény az update-lánc melyik szakaszában
hívódott meg.

Ahogy látható, mindkét megoldásnak megvannak az elõnyei illetve a hátrányai egyaránt, éppen ezért
a felhasználó dönthet arról, hogy mikor melyik módszert kívánja használni a bemeneti események
kezelésére.

%----------------------------------------------------------------------------
\section{Transzformációk kezelése}
%----------------------------------------------------------------------------
A szakdolgozatomban a játékobjektumok tagváltozóként tartalmazták a kurrens pozíciójukat illetve
orientációjukat, ennek megfelelõen különálló, transzformációkért felelõs komponens még nem létezett
a rendszerben akkoriban.
Ez azért nem volt elõnyös, mert a rendszer bõvítési ötletei között szerepelt a
játékobjektumok hierarchiába történõ rendezésének képessége, aminek így a megvalósítása is a
játékobjektumokat reprezentáló osztályba került volna elhelyezésre, túlságosan megnövelve annak méretét,
illetve megnehezítve annak kezelését.

Ennek a problémának a kiküszöbölésére hoztam létre a rendszeremben a geometriai transzformációkért
(eltolás, forgatás illetve skálázás) felelõs motor oldali komponenst, a TransformComponent-et.
A rendszeremben ez az egyik legfontosabb komponens típus, ugyanis ez az egyetlen olyan komponens-
leszármazott, melyet alapértelmezetten hozzárendelek minden játékobjektumhoz. Emellett természetesen
rengeteg más komponens is támaszkodik a transzformációs komponens különbözõ funkcionalitására, így
nyugodtan kijelenthetem, hogy a motorom egyik alappillérét képezi ez az osztály, helyes és hatékony
mûködése tehát kulcskérdés a rendszer egésze szempontjából. Elég, ha csak arra gondolunk, hogy a
játékobjektumok hierarchiákba rendezõdhetnek, így a gyerek játékobjektumnak örökölnie kell a szülõ
játékobjektumnak a transzformációit (eltolás, forgatás, skálázás), illetve ha a felhasználó egy
gyerek játékobjektumnak a transzformációit kívánja megadni, akkor azt a szülõ játékobjektum koordináta-
rendszerében kell megtennie.

Viszont amilyen fontos ennek az osztálynak a helyes és hatékony mûködése, annyira nem triviális ennek
az állapotnak az elõidézése, ugyanis ehhez nélkülözhetetlenek matematikai -- fõleg lineáris algebrai --
alapismeretek.

A megvalósításhoz a TransformComponent nyílván tartja a hozzá tartozó játékobjektum transzformációs
adatait (eltolást, forgatást, skálázást illetve az ezeket egységben reprezentálni képes transzformációs mátrixot) mind világtérben, mind a szülõ koordináta-rendszerében. Bármilyen módosítás hatására be kell
frissíteni az összes vektort/kvaterniót/mátrixot a konzisztens állapot érdekében. A sok tagváltozó miatt
az osztály getter függvényeinek költsége elhanyagolható, viszont az elõbb említett konzisztens
állapot megtartása miatt a setter függvények költsége nagyságrendekkel nagyobb, de ez összességében
nem volt zavaró tényezõ a fejlesztés és a tesztelés során sem. Egyébként is a helyes mûködést ez a
diplomaterv fontosabbnak tartja, mint a villámgyors mûködést.

%----------------------------------------------------------------------------
\section{Erõforrások kezelése}
%----------------------------------------------------------------------------
Korábban nem fordítottam kellõ figyelmet az erõforrások kezelésére, hiszen lényegtelen volt, hogy
milyen fájlszerkezetben vannak elhelyezve, illetve milyen módon vannak betöltve. Csak az számított,
hogy a betöltés sikeres legyen. Ezzel nem is volt gond addig, amíg a motor illetve a hozzá tartozó
példa alkalmazás kis méretû volt, s kevés erõforrást használt.

Viszont ahogy nõtt a felhasználandó erõforrások száma, úgy kezdett egyre nehézkesebbé válni
a kezelésük. A rengeteg fájl egyetlen mappába sûrítve átláthatatlanná tette azt, hogy mely
erõforrások tartoznak össze, s melyek nem. Továbbá azt sem volt triviális kideríteni, hogy
mely erõforrások redundánsak, vagy éppen használaton kívüliek a példa alkalmazás által.

A problémák megoldására a motor oldalon ``beégetett'' elérési út helyett config fájlokat kezdtem
el használni, s azokat beparszolni betöltéskor. Emellett az erõforrások tárolási módján is változtattam.
Ezelõtt az erõforrásokat típusuk szerint tároltam (a mesh-ek együtt, a textúrák együtt, a materialok
együtt stb.), mostantól viszont az erõforrásokat objektumonként tárolom, ami azt jelenti, hogy egy
adott objektumhoz tartozó fájlok egy egységben foglalnak helyett, jól elkülönítve a többi
erõforrástól.

Ennek a megoldásnak talán a legnagyobb elõnye, hogy új erõforrások illetve elérési utak felvétele
után a programot nem kell újrafordítani (hiszen ettõl a config fájl parszolása nem változik meg),
így jelentõs idõt lehet megtakarítani. Emellett ha egy másik játékban is használni szeretnék egy
objektumot, akkor nem kell megkeresni a hozzá tartozó erõforrásokat a különbözõ almappákból,
tehát ezzel a megoldással az erõforrások újra felhasználhatóak más kontextusban is.
Végül, de nem utolsó sorban mivel ezek az erõforrásokból álló egységek tömörítve foglalnak helyet a
számítógép háttértárán (.zip fájlok), így tárterületet is lehet spórolni ezzel a megoldással.

resource group-okra bontas fajlrendszer szinten es a leiro fajlban is (minden resource group egy
jelenetnek feleltethetõ meg)

%----------------------------------------------------------------------------
\section{Anyagok leírása}
%----------------------------------------------------------------------------
Egy játékmotor lehet akármennyire jól használható, rugalmas és hatékony, ha nem tud grafikailag
elfogadható eredményt produkálni vele a felhasználó, akkor igazából nem jó semmire.

Az OGRE-ben az anyagok leírására material script-eket szokás használni. Ezek olyan szkriptek, melyek
segítségével könnyen olvasható formában lehet leírni a legkülönfélébb anyagokat, illetve kényelmesen
lehet árnyalóprogramoknak paramétereket átadni. Pontosabban az anyagleíró szkriptekben nem közvetlenül
árnyalóprogramokat, hanem azok egy OGRE-ben definiált absztrakcióit, az úgynevezett programokat
használhatjuk.

Az árnyalóprogramok tekintetében csak az OpenGL jöhetett szóba, melynek árnyalónyelve a GLSL. Egy
alternatíva lehetett volna a DirectX is, de ennek használata akadályokba ütközött, lásd <TODO> fejezet.

Itt meg le kene irni, hogy milyen shader-eket hasznaltam az egyes objektumokra

<RÉGI KÉP, AMELYEN SZINTE MINDEN SZURKE VOLT> -- OpenGL-lel, de meg a regi HLSL shaderek hasznalataval

<ÚJ KÉP, MÁR A VÉGLEGES SHADER-EKKEL>
