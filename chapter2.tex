%----------------------------------------------------------------------------
\chapter{A keretrendszer átdolgozása}
%----------------------------------------------------------------------------
Ez a fejezet bemutatja azokat a módszereket, melyek segítségével módosítottam a szoftverkörnyezet
felépítését annak érdekében, hogy annak build-elési módja, karbantarthatósága illetve bõvíthetõsége
javuljon a korábbi rendszerhez képest.

%----------------------------------------------------------------------------
\section{Projektek build-elése}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Build-elési idõ csökkentése}
%----------------------------------------------------------------------------
C++ projektek esetében nem lehet figyelmen kívül hagyni a build-elési idõ hosszát, hiszen ez az
egyik leglassabban build-elõ programozási nyelv, ami a komplexitásából adódik. Korábbi munkáim
során nem törõdtem ezzel a metrikával, hiszen a projektek mérete és bonyolultsága miatt az
újrabuild-elések ideje sem volt számottevõ, viszont a szakdolgozatom eredményeként megszületett
szoftverre ezt nem lehetett elmondani. A fejlesztési idõ vége felé kifejezetten hosszú ideig tartott
egy-egy kisebb módosítás utáni build-elés ideje is, ezért határoztam el azt, hogy idõmet és energiámat
nem sajnálva megpróbálom csökkenteni a build-elési folyamat idejét, hiszen ha ezt nem tenném meg, akkor
a késõbbi -- feltehetõleg nagyobb -- kódbázis esetén a várakozási idõk még hosszabbak lennének.

Az legfontosabb követendõ elv volt számomra a header fájlok szerepének csökkentése. Ez azt
jelenti, hogy minimalizálni kell az \verb+#include+-okat illetve a függvény definíciókat ezekben
a fájlokban. Mindez azért hasznos, mert így csökkenthetõ a header fájlok változási gyakorisága, így
ritkábban kell azokat illetve az azokat használó fájlokat újrafordítani. Tehát egy source fájlban
történõ változás sokkal ``olcsóbb'', mint egy header-beli változás, mivel a source fájlt nem 
\verb+#include+-olja senki, így a változása nem érint más fájlokat.

A header fájlokban levõ \verb+#include+-ok számának minimalizálására egy bevált módszer az elõdeklarálás
módszere. Ennek az a lényege, hogy ha egy header fájlban használok egy szimbólum nevet (pl.: egy osztály
neve), viszont nem használom annak definícióját (pl.: egy osztály tagfüggvényét), akkor igazából
abban a fájlban nincs is szükség a használt szimbólum definíciójára, csak a nevének elõdeklarálására.
Ebben az esetben a tényleges definíció használata -- tehát a tényleges \verb+#include+-olás -- a source
fájlban történik meg. Megjegyzendõ, hogy ez a módszer hatékonyan használható a körkörös dependenciák
problémájának feloldására is. Mindezeken túl a dependenciák számának kordában tartására is megfelelõ
módszer az \verb+#include+-ok számának minimalizálása, hiszen gondoljunk csak bele, ha egy header
fájlt valamely kódrészbe beemelek, akkor nem csak annak a tartalma, hanem az õ \verb+#include+
fájljainak a tartalma is beemelõdik, és így tovább, tranzitív módon. Így könnyen elõfordulhat, hogy
a ténylegesen beemelt kódmennyiségnek csak a töredékét szeretnénk ténylegesen használni.

\begin{lstlisting}[frame=single,float=!ht,
caption={Példa elõdeklarálásra a C++ nyelvben}, label=ForwardDeclarationCpp]
// forward declaration of class A
class A;
class B
{
	A* pA;	// there is no need for the definition of class A
};
\end{lstlisting}

Egy másik technika is a header fájlokhoz köthetõ, miszerint használjunk include guard-okat. Ennek
a techikának a lényege, hogy a header tartalmát a compiler csak akkor parszolja be, ha azt még nem
tette meg. Ezt header fájlonként külön makrók definiálásával tehetjük meg. Modernebb fordítók támogatják
a \verb+#pragma once+ preprocesszor parancsot is, melynek használatával ugyan azt az eredményt lehet
elérni, mint az include guard-os makrók definiálásával. Az én kódjaimban a két ismertetett megoldást
együtt használom, melynek magyarázata <INSERT MAGYARÁZAT HERE>.

\begin{lstlisting}[frame=single,float=!ht,
caption={Include guard és pragma once együttes használata}, label=IncludeGuardsCpp]
#ifndef INCLUDE_GUARD
#define INCLUDE_GUARD

#pragma once

/* header content goes here*/

#endif
\end{lstlisting}

Az imént említett módszerek mellett népszerû megoldás az elõfordított header fájlok használata is.
Ennek a technikának az a lényege, hogy létrehozunk egy olyan header fájlt, melyben az olyan
\verb+#include+-olások szerepelnek, melyek nagy méretûek, sok helyen kell használni õket illetve
soha -- vagy csak nagyon ritkán -- változnak. Ennek a fájlnak a létrehozása után megmondhatjuk
a kurrens fordítónak -- ha az támogatja --, hogy kezelje ezt a header fájlt elõfordítottként, vagyis
ezt fordítsa le elsõnek, és egyetlen egyszer, s linkeléskor a már meglevõ object fájlt kelljen
használni. Ez is tipikusan egy olyan módszer, mellyel esetenként többszörös gyorsulást lehet
elérni az eredeti build-elési módszerhez képest, viszont ha nem megfelelõen használják, akkor
akár többet is árthat, mint használhat.

A felsorolt módszereken kívül természetesen még számos más technika is létezik a C++-os projektek
build-elési idejének csökkentésére, s a lista valószínûleg a jövõben még tovább fog gyarapodni, hiszen
az gyorsításra való igény továbbra is megvan a fejlesztõk körében.
%----------------------------------------------------------------------------
\subsection{Binárisok méreteinek csökkentése}
%----------------------------------------------------------------------------
Mint ahogy arról korábban már írtam, a motort egy dinamikus könyvtárba fordítom bele.
Ahhoz, hogy az egyes motorban implementált funkcionalitások a játéklogika oldalán is elérhetõek legyenek,
explicite meg kell mondani a fordítóprogramnak, hogy azt tegye elérhetõvé a könyvtárt használók számára.
Ezt gyakran úgy szokták megoldani, hogy ha egy osztálynak egy adott függvényére szükség van a könyvtáron
kívül is, akkor az egész osztály kikerül a könyvtár publikus interfészére. Ez gyakran nem túl szerencsés,
ugyanis legtöbbször ezzel a megoldással sok olyan dolgot is kiajánlunk a könyvtár használói számára,
melyekre igazából nincs is szükségük. Ezzel a megközelítéssel éppen ezért indokolatlanul nagyra
lehet növelni a könyvtár méretét.

Ennek a problémának a megoldására minimalizáltam a könyvtárba bekerülõ tartalmat, melynek hatására
a motor mérete 3.35MB-ról 3.29MB-ra, a játék mérete 475KB-ról 290 KB-ra csökkent.

Ezek mellett kijavítottam egy régóta elhúzódó hibát, melynek az volt a kiváltó oka, hogy a Bullet-hez
-- figyelmetlenségem miatt -- statikusan linkeltem a C Runtime-ot, melynek következtében a motoromnál
is rá voltam kényszerülve a statikus linkelésre a linker error-ok elkerülése végett. A példajáték viszont
továbbra is dinamikusan linkelte magához a C Runtime-ot, aminek következtében elõfordulhattak olyan
esetek dinamikus memóriafoglalásnál, mikor pl. a motor oldalon foglalom le a memóriát, de a játék oldalon
próbálom felszabadítani, ami a legjobb esetben is assert-et okoz, mivel a játék egy olyan memóriaterületet
akar felszabadítani, amit nem is lát, mivel másik heap-en lett foglalva.

Ezt -- miután rájöttem a hiba forrására -- már triviális volt kijavítani, hiszen csak a megfelelõ
Bullet-hez tartozó statikus könyvtárakat kellett újrafordítani úgy, hogy dinamikusan linkeljék
magukhoz a C Runtime-ot, majd az engine-re is alkalmazva ezt a beállítást a fentebb említett
problémák megszûntek. A javítás után az engine mérete -- mivel már nem tartalmazta magában a
C Runtime-ot -- lecsökkent 1.8MB-ra.

%----------------------------------------------------------------------------
\subsection{CMake használata}
%----------------------------------------------------------------------------
ide kell minden a cmake-rol

hátha más platformon is mûködne a programom

a visual studio beállításai között matatni sem leányálom + könnyû elrontani
nagy projekteknél ez egyszerûbb, mint mindig kézzel beállítani a dependenciákat a user-eknél

a visual studio nem szemeteli tele a forras konyvtarakat

A projekt könyvtárszerkezetének kialakítása

%----------------------------------------------------------------------------
\section{XML-feldolgozó módosítása}
%----------------------------------------------------------------------------
namespace-esites
%----------------------------------------------------------------------------
\section{Erõforrások kezelése}
%----------------------------------------------------------------------------
Korábban nem fordítottam kellõ figyelmet az erõforrások kezelésére, hiszen lényegtelen volt, hogy
milyen fájlszerkezetben vannak elhelyezve, illetve milyen módon vannak betöltve. Csak az számított,
hogy a betöltés sikeres legyen. Ezzel nem is volt gond addig, amíg a motor illetve a hozzá tartozó
példa alkalmazás kis méretû volt, s kevés erõforrást használt.

Viszont ahogy nõtt a felhasználandó erõforrások száma, úgy kezdett egyre nehézkesebbé válni
a kezelésük. A rengeteg fájl egyetlen mappába sûrítve átláthatatlanná tette azt, hogy mely
erõforrások tartoznak össze, s melyek nem. Továbbá azt sem volt triviális kideríteni, hogy
mely erõforrások redundánsak, vagy éppen használaton kívüliek a példa alkalmazás által.

A problémák megoldására a motor oldalon ``beégetett'' elérési út helyett config fájlokat kezdtem
el használni, s azokat beparszolni betöltéskor. Emellett az erõforrások tárolási módján is változtattam.
Ezelõtt az erõforrásokat típusuk szerint tároltam (a mesh-ek együtt, a textúrák együtt, a materialok
együtt stb.), mostantól viszont az erõforrásokat objektumonként tárolom, ami azt jelenti, hogy egy
adott objektumhoz tartozó fájlok egy egységben foglalnak helyett, jól elkülönítve a többi
erõforrástól.

Ennek a megoldásnak talán a legnagyobb elõnye, hogy új erõforrások illetve elérési utak felvétele
után a programot nem kell újrafordítani (hiszen ettõl a config fájl parszolása nem változik meg),
így jelentõs idõt lehet megtakarítani. Emellett ha egy másik játékban is használni szeretnék egy
objektumot, akkor nem kell megkeresni a hozzá tartozó erõforrásokat a különbözõ almappákból,
tehát ezzel a megoldással az erõforrások újra felhasználhatóak más kontextusban is.
Végül, de nem utolsó sorban mivel ezek az erõforrásokból álló egységek tömörítve foglalnak helyet a
számítógép háttértárán (.zip fájlok), így tárterületet is lehet spórolni ezzel a megoldással.

%----------------------------------------------------------------------------
\section{Anyagok leírása}
%----------------------------------------------------------------------------
material scriptek es shaderek modositasa

átállás directx-rol opengl-re

hlsl helyett glsl

ez az ogre verzio nem a directx9-et, hanem a 11-et támogatja, amiben már
nincs fixed function pipeline

esetleges multiplatformositas miatt is jobb az opengl
