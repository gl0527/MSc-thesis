%----------------------------------------------------------------------------
\chapter{Demonstrációs alkalmazás}\label{sect:DemoApp}
%----------------------------------------------------------------------------
Ez a fejezet a játékmotor mûködésének demonstrálására készített példa alkalmazást mutatja be.
Elõször is tisztázza az alkalmazással szemben támasztott követelményeket, aztán kitér a megvalósítás
részleteire is, majd az elkészült alkalmazás áttekintése után a tesztelési eredmények taglalásával
zárul.

%----------------------------------------------------------------------------
\section{Követelmények}
%----------------------------------------------------------------------------
A követelmények meghatározásakor arra kellett törekednem, hogy az elkészített motor képességeire
minél jobban támaszkodjon az elkészítendõ demonstrációs alkalmazás. Fontos szempont volt továbbá az is, hogy
a példa alkalmazásnak "legyen értelme", vagyis legyen kezdeti állapota és célja, illetve hogy
ne csak nyerni, hanem veszteni is lehessen benne.

Ezen szempontokat is figyelembe véve egy zárt térben játszódó FPS (First Person Shooter) játék
megvalósítására vállalkoztam, ahol a felhasználó által irányított játékosnak nincsenek segítõi, csak
ellenfelei, melyek a pálya adott pontjain jelenhetnek meg, s mohó módon a játékos felé tartanak, ha
életerejük nagyobb, mint egy, különben menekülnek a játékos elõl. Az ellenséges objektumok hullámokban
jelennek meg a színtéren, mégpedig úgy, hogy az n. hullám kezdetekor 2n darab új ellenséges objektum
keletkezik. Az ellenséges objektumok számára nincs felsõ korlát, ilyen értelemben ez egy végtelenített
játék, amelynek csak akkor van vége, ha a játékos karakterének az életereje nullára csökken.

%----------------------------------------------------------------------------
\section{Megvalósítás}
%----------------------------------------------------------------------------
Ez a szakasz az alkalmazás során megvalósított fontosabb osztályok bemutatását tartalmazza.

%----------------------------------------------------------------------------
\subsection{DynamicMovementComponent}
%----------------------------------------------------------------------------
Ennek a komponens leszármazottnak az a feladata, hogy dinamikus fizikai komponenssel rendelkezõ
játékobjektum felhasználói inputokkal történõ transzformálását megoldja illetve a fizikai ütközésekkor
bekövetkezõ eseményeket lekezelõ függvények definiálását megtegye. Ennek megfelelõen ez a komponens
felel a felhasználót reprezentáló karakter transzformációjának módosításáért (\figref{DemoAppUnarmedRun} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/demoapp_unarmed_run.png}
\caption{Példa a játékos karakterének transzformálására.}
\label{fig:DemoAppUnarmedRun}
\end{figure}

%----------------------------------------------------------------------------
\subsection{EnemyAIComponent}
%----------------------------------------------------------------------------
Ez a komponens leszármazott nagyon hasonlít az elõzõekben ismertetett \verb+DynamicMovementComponent+
osztályhoz, ugyanis ez az osztály is dinamikus fizikai komponenssel rendelkezõ objektum transzformálását
és az ütközéseinek kezelését végzi, annyi különbséggel, hogy ebben az esetben nem a felhasználói
bemenetek, hanem egy belsõ logika dönt az elmozdulás és az elforgatás milyenségérõl. Ahogy arra a
komponens nevébõl is következtetni lehet, ez az osztály felelõs az ellenséges játékobektumok
transzformációjának módosításáért.

A megvalósítás során 4 állapotot definiáltam az ellenséges karakterek számára, ezek rendre a \verb+Search+,
\verb+Attack+, \verb+RunAway+ és \verb+Dead+ állapotok (\figref{EnemyAIStateGraph} ábra). Az állapotokhoz tartozó
függvényeket illetve az állapotátmenetek
menedzselését a motor oldali generikus állapotgép segítségével, a \verb+FiniteStateMachine+ osztály
felhasználásával valósítottam meg. Ami az implementáció mesterséges intelligenciára vonatkozó részét
illeti, az állapotgéphez rendelt állapotfüggvényeknek az a feladatuk, hogy a felhasználó által
irányított karakterhez képest meghatározza az kívánt elmozdulás irányát és az elforgatás szögét, s ezeknek
megfelelõen erõk illetve forgatónyomatékok segítségével elvégzi a szükséges transzformációkat.
Látható, hogy ez a megoldás meglehetõsen korlátozott intelligenciát ruház az ellenséges játékobjektumokra,
hiszen mivel ez egy mohó algoritmus (azaz mindig az aktuális állapot alapján dönt, determinisztikusan),
így például az akadályok kikerülése, a kooperáció stb. nem megoldható ezzel a megvalósítással.

\begin{figure}[!ht]
\centering
\includegraphics[width=70mm, keepaspectratio]{figures/enemyAIState.png}
\caption{Az ellenséges objektumok mesterséges intelligenciájának állapotgráfja.}
\label{fig:EnemyAIStateGraph}
\end{figure}

%----------------------------------------------------------------------------
\subsection{EnemyAnimationComponent}
%----------------------------------------------------------------------------
Ennek az \verb+AnimationComponent+-leszármazottnak az a feladata, hogy az ellenséges játékobjektumok animálását
menedzselje a motor oldali \verb+FiniteStateMachine+ osztály segítségével.

Az implementáció során 3 animációs állapotot definiáltam, ezek rendre a \verb+Walk+, \verb+Attack+ és \verb+Dead+
állapotok (\figref{EnemyAnimStateGraph} ábra). Természetesen ezek az állapotok összefüggnek az imént ismertetett \verb+EnemyAIComponent+-ben
definiált állapotokkal a következõ módon: amikor az \verb+EnemyAIComponent+ \verb+Search+ vagy \verb+RunAway+
állapotban van, akkor az \verb+EnemyAnimationComponent+ \verb+Walk+ állapotban, illetve minden más
\verb+EnemyAIComponent+-beli állapothoz a vele megegyezõ nevû \verb+EnemyAnimationComponent+-beli állapot tartozik.

\begin{figure}[!ht]
\centering
\includegraphics[width=70mm, keepaspectratio]{figures/EnemyAnimState.png}
\caption{Az ellenséges objektumok animációjának állapotgráfja.}
\label{fig:EnemyAnimStateGraph}
\end{figure}

%----------------------------------------------------------------------------
\subsection{GUIComponent}
%----------------------------------------------------------------------------
Ez a komponens-leszármazott felel a MyGUI szkriptek segítségével definiált felhasználói felület
menedzseléséért, amibe beletartozik a menüelemekhez kötõdõ események kezelése illetve magának a menünek
a megjelenítése és elrejtése a játékmenet aktuális állapotának megfelelõen. A példa alkalmazásomban
ez az egyetlen olyan komponens, mely dinamikus (azaz reszponzív) felhasználói felületet valósít meg.

A példa alkalmazásban felhasznált, MyGUI segítségével megalkotott felhasználói felület a \figref{MyGUI_Example}
ábrán látható.

\begin{figure}[!ht]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/mygui_example.png}
\caption{Reszponzív felhasználói felület kialakítása a MyGUI felhasználásával.}
\label{fig:MyGUI_Example}
\end{figure}

%----------------------------------------------------------------------------
\subsection{HUDComponent}
%----------------------------------------------------------------------------
Ez a komponens leszármazott is -- a korábbiakban ismertetett \verb+GUIComponent+-hez hasonlóan -- felhasználói
felület menedzselésével foglalkozik, annyi különbséggel, hogy ez az osztály az Ogre Overlay keretrendszert
használja a felhasználó számára fontosnak tartott információk
(aktuális életpont, aktuális töltények száma, megölt ellenfelek száma illetve az aktuális kör sorszáma) képernyõn
történõ megjelenítésére. Ennek megfelelõen az ezzel a komponenssel megjelenített felhasználói felület --
a GUIComponent-ével ellentétben -- statikus, nem pedig dinamikus, vagyis felhasználói eseményekre nem képes
reagálni.

A demonstrációs alkalmazásban informatív szerepet betöltõ statikus felhasználói felületre mutat példát a
\figref{DemoAppKill} ábra.

\begin{figure}[!ht]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/demoapp_kill.png}
\caption{Példa a statikus felhasználói felület informatív szerepére.}
\label{fig:DemoAppKill}
\end{figure}

%----------------------------------------------------------------------------
\subsection{ManagerComponent}
%----------------------------------------------------------------------------
Ez a komponens-leszármazott felel a pályán megjelenõ ellenséges játékobjektumok megfelelõ ütemben
és helyen történõ létrehozásáért. Emellett ennek az osztálynak a feladata az is, hogy a \verb+HUDComponent+-et
tájékoztassa a szükséges mennyiségek aktuális értékeirõl. Ennek megvalósításához felhasználja a játékost reprezentáló
objektumhoz rendelt \verb+PlayerDataComponent+-et (\sectref{PlayerDataComponent}. alszakasz) és
\verb+WeaponComponent+-et (\sectref{WeaponComponent}. alszakasz) egyaránt.

%----------------------------------------------------------------------------
\subsection{PlayerDataComponent}\label{sect:PlayerDataComponent}
%----------------------------------------------------------------------------
Ennek a komponensnek az a feladata, hogy a felhasználó által irányított karakter illetve az ellenséges
játékobjektumok legfontosabb közös tulajdonságait (életerõ, megölt ellenfelek száma illetve egy flag
arról, hogy van-e nála fegyver) menedzselje.

%----------------------------------------------------------------------------
\subsection{SoldierAnimationComponent}
%----------------------------------------------------------------------------
Ez a speciális \verb+AnimationComponent+ azért felel, hogy a felhasználó által irányított játékobjektum
mindig a megfelelõ animációval legyen ellátva.

Implementációs szinten ez az osztály úgy viszonyul a \verb+DynamicMovementComponent+-hez, mint ahogy
az \verb+EnemyAnimationComponent+ viszonyult az \verb+EnemyAIComponent+-hez, annyi különbséggel, hogy a
\verb+DynamicMovementComponent+-ben nincs állapothalmaz, viszont ebben az osztályban kettõ is van.

A két állapothalmazra azért van szükség, mert a felhasználó által irányított játékobjektum
animációinak nagy része vagy csak a karakter felsõ testére, vagy csak annak az alsó testére vonatkozik,
ennek megfelelõen a különbözõ halmazokban levõ állapotok egymástól függetlenül kezelendõk. Ez kódszinten
azt jelenti, hogy két \verb+FiniteStateMachine+ példányt kell menedzselnie ennek az osztálynak.

Az alsó testre vonatkozó állapothalmaz állapotait az \verb+Idle+, \verb+Run+ és \verb+Dead+ állapotok alkotják, míg
a felsõ testen használatos állapothalmazba az \verb+Idle+, \verb+Run+, \verb+WeaponHold+, \verb+Shoot+ és \verb+Dead+
állapotok tartoznak (\figref{SoldierAnimStateGraph} ábra). Megjegyzendõ, hogy az állapotok és az animációk között nem
egyértelmû a leképezés, hiszen a death animáció (\figref{DemoAppDead} ábra) mind az alsó testre, mind a felsõ testre
vonatkozik, viszont mindkét állapotgépben szerepel a hozzá tartozó állapot a helyes mûködés elõidézése érdekében.

\begin{figure}[!ht]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/soldierAnimState.png}
\caption{A felhasználó által irányított karakter alsó- illetve felsõtestre vonatkozó animációs gráfjai.}
\label{fig:SoldierAnimStateGraph}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/demoapp_dead.png}
\caption{Az ellenséges karakterek elpusztítják a felhasználó által irányított játékobjektumot.}
\label{fig:DemoAppDead}
\end{figure}

%----------------------------------------------------------------------------
\subsection{SoldierAnimComponent}
%----------------------------------------------------------------------------
A \sectref{Engine}. fejezetben leírtaknak megfelelõen nem csak a \verb+FiniteStateMachine+ osztály felhasználásával,
hanem a State tervezési minta alkalmazásával is lehet állapotgép funkciókat megvalósítani.

Ez az osztály a neve ellenére nem komponens, hanem \verb+Stateable+ leszármazott, ennek megfelelõen
\verb+IState+ leszármazottak segítségével meg lehet adni a mindenkori aktuális állapotát. Az osztály nevében azért szerepel
mégis a Component utótag, mert ezzel is szerettem volna arra utalni, hogy használhatóságát tekintve nem sokban különbözik
bármely \verb+Component+ leszármazottól.
Ehhez definiáltam három darab \verb+AnimState+ leszármazottat, melyek singleton objektumok, s egymás között
döntik el, hogy adott feltételek esetén melyikük legyen a hozzájuk tartozó \verb+SoldierAnimComponent+
példány aktuális állapota. Az elkészített rendszer szereplõit illetve azok kapcsolatait a \figref{GameSideStateHierarchy}
ábra foglalja össze.

\begin{figure}[!ht]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/demoapp_state.png}
\caption{A rendszeremben megvalósított State tervezési minta UML osztálydiagrammja.}
\label{fig:GameSideStateHierarchy}
\end{figure}

%----------------------------------------------------------------------------
\subsection{WeaponComponent}\label{sect:WeaponComponent}
%----------------------------------------------------------------------------
Ez a komponens menedzseli a játékos karaktere által felvehetõ fegyver objektumot. A menedzselésbe
beletartozik a töltények számának kezelése, illetve maga a lövési folyamat definiálása is, mely során
a fizikai rendszer segítségével fizikai first hit raycasting-ot használva a fegyver csövébõl lõtt
sugárral metszi el a színteret, s az elsõként eltalált fizikai objektumtól von le életet akkor, ha az
az objektum egy ellenséges karakter volt (azt, hogy egy játékobjektum ellenség-e, a hozzá rendelt tag-ek
alapján lehet eldönteni). Mindezek mellett szintén ennek a komponensnek a feladata, hogy
a szülõ játékobjektumhoz képest megfelelõ transzformációval lássa el a fegyvert reprezentáló
játékobjektumot. Ezt úgy valósítja meg, hogy a szülõ játékobjektum jobb kezéhez képest alkalmaz
egy x tengely körüli, 90°-os elforgatást (\figref{WeaponHoldDemo} ábra).

\begin{figure}[!ht]
\centering
\includegraphics[width=100mm, keepaspectratio]{figures/weapon_transform.png}
\caption{A fegyver helyzete a katona kezéhez igazítva.}
\label{fig:WeaponHoldDemo}
\end{figure}

%----------------------------------------------------------------------------
\section{Áttekintés}
%----------------------------------------------------------------------------
Az imént ismertetett játéklogika-oldali komponensek kapcsolatait összefoglaló UML osztálydiagramm
a \figref{GameSideCompHierarchy} ábrán látható.

\begin{figure}[!ht]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/gameside_comp_hierarchy.png}
\caption{A játéklogika oldalon elkészített fontosabb komponensek UML osztálydiagrammja.}
\label{fig:GameSideCompHierarchy}
\end{figure}
